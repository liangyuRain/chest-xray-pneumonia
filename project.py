# -*- coding: utf-8 -*-
"""Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/liangyuRain/chest-xray-pneumonia/blob/master/Project.ipynb
"""

import torch
import torch.nn as nn
import numpy as np
import scipy
import os

import torch.nn.functional as F
import torch.optim as optim
import torchvision
from torchvision import datasets, transforms

import torch.utils.data

import matplotlib
import matplotlib.pyplot as plt

def train(model, device, train_loader, optimizer, epoch, log_interval):
    model.train()
    losses = []
    for batch_idx, (data, label) in enumerate(train_loader):
        data, label = data.to(device), label.to(device)
        optimizer.zero_grad()
        
        output = model(data)

        # for handling tuple outputs as in Inception V3 model
        if isinstance(output, tuple):
            loss = sum((model.loss(o, label) for o in output))
        else:
            loss = model.loss(output, label)

        losses.append(loss.item())
        loss.backward()
        
        optimizer.step()
        if batch_idx % log_interval == 0:
            print('Train Epoch: {} [{}/{} ({:.0f}%)]\tLoss: {:.6f}'.format(
                epoch, batch_idx * len(data), len(train_loader.dataset),
                100. * batch_idx / len(train_loader), loss.item()))
    return np.mean(losses)


def test(model, device, test_loader):
    model.eval()
    test_loss = 0
    correct = 0
    with torch.no_grad():
        for data, label in test_loader:
            data, label = data.to(device), label.to(device)
            output = model(data)
            test_loss += model.testLoss(output, label).item()
            pred = output.max(1, keepdim=True)[1]
            correct += pred.eq(label.view_as(pred)).sum().item()

    test_loss /= len(test_loader.dataset)
    test_accuracy = 100. * correct / len(test_loader.dataset)
    
    print('\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\n'.format(
        test_loss, correct, len(test_loader.dataset),
        100. * correct / len(test_loader.dataset)))
    return test_loss, test_accuracy

LR = 0.1
WEIGHT_DECAY = 0.0001
MOMENTUM = 0.9
EPOCHS = 100
BATCH_SIZE = 32
USE_CUDA = True
SEED = 0
LOG_INTERVAL = 20
LAYERS_TO_TRAIN = 1
MODEL = 'DENSE'
#'VGG' #'ALEX' #'RES' #'DENSE' #'INCEPT'
NUM_CLASSES = 2


use_cuda = USE_CUDA and torch.cuda.is_available()
torch.manual_seed(SEED)
device = torch.device("cuda" if use_cuda else "cpu")
print('Using device', device)

import multiprocessing
print('num cpus:', multiprocessing.cpu_count())
kwargs = {'num_workers': multiprocessing.cpu_count(),
          'pin_memory': True} if use_cuda else {}

resize_flag = True
input_size = (224, 224)
if MODEL == 'INCEPT':
    model = torchvision.models.inception_v3(pretrained=True)
    input_size = (299, 299)
elif MODEL == 'VGG':
    model = torchvision.models.vgg16(pretrained=True)        
elif MODEL == 'ALEX':
    model = torchvision.models.alexnet(pretrained=True)
elif MODEL == 'DENSE':
    model = torchvision.models.densenet161(pretrained=True)
elif MODEL == 'RES':
    model = torchvision.models.resnet18(pretrained=True)


# set categories to NUM_CLASSES (2 by default)
if MODEL == 'INCEPT' or MODEL == 'RES': 
    num_ftrs = model.fc.in_features
    model.fc = nn.Linear(num_ftrs, NUM_CLASSES, bias=True)
elif MODEL == 'ALEX' or MODEL == 'VGG':
    num_ftrs = model.classifier[len(model.classifier)-1].in_features
    model.classifier = nn.Sequential(
        *(model.classifier[i] for i in range(len(model.classifier)-1)),
        nn.Linear(num_ftrs, NUM_CLASSES, bias=True)
    )
elif MODEL == 'DENSE':
    num_ftrs = model.classifier.in_features
    model.classifier = nn.Linear(num_ftrs, NUM_CLASSES, bias=True)
else:
    pass

# avoid training pretrained model
for layer in list(model.children())[:-LAYERS_TO_TRAIN]:
    for param in layer.parameters():
        param.requires_grad = False

print(model)

model = model.to(device)

criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(filter(lambda p: p.requires_grad, model.parameters()), 
                      lr=LR, 
                      momentum=MOMENTUM, 
                      weight_decay=WEIGHT_DECAY)

model.loss = nn.CrossEntropyLoss()
model.testLoss = nn.CrossEntropyLoss(reduction='sum')


class ImageLoader(object):

    def __init__(self, batchSize):
        super(ImageLoader, self).__init__()
        if (resize_flag):
            transform_train = transforms.Compose([
                transforms.Resize(size=input_size),
                transforms.RandomHorizontalFlip(),
                transforms.ToTensor(),
                transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
            ])

            transform_test = transforms.Compose([
                transforms.Resize(size=input_size),
                transforms.ToTensor(),
                transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
            ])
        else:
            transform_train = transforms.Compose([
                transforms.RandomHorizontalFlip(),
                transforms.ToTensor(),
                transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
            ])

            transform_test = transforms.Compose([
                transforms.ToTensor(),
                transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
            ])

        train_dataset = datasets.ImageFolder(root='chest_xray_dataset/train',
                                             transform=transform_train)
        self.trainloader = torch.utils.data.DataLoader(train_dataset,
                                                       batch_size=batchSize,
                                                       shuffle=True,
                                                       num_workers=8)

        test_dataset = datasets.ImageFolder(root='chest_xray_dataset/test',
                                            transform=transform_test)
        self.testloader = torch.utils.data.DataLoader(test_dataset,
                                                      batch_size=batchSize,
                                                      shuffle=False,
                                                      num_workers=8)

        self.classes = ('normal', 'pneumonia')

def plot(data, title, xlab, ylab):
    x_val = [x[0] for x in data]
    y_val = [x[1] for x in data]
    plt.plot(x_val, y_val)
    plt.title(title)
    plt.xlabel(xlab)
    plt.ylabel(ylab)
    plt.show()

loader = ImageLoader(batchSize=BATCH_SIZE)
train_losses = []
test_losses = [] 
test_accuracies = []

try:
    for epoch in range(EPOCHS + 1):
        train_loss = train(model, device, loader.trainloader, optimizer, epoch, LOG_INTERVAL)
        test_loss, test_accuracy = test(model, device, loader.testloader)
        train_losses.append((epoch, train_loss))
        test_losses.append((epoch, test_loss))
        test_accuracies.append((epoch, test_accuracy))
except KeyboardInterrupt as ke:
    print('Interrupted')
except:
    import traceback
    traceback.print_exc()
finally:
    plot(train_losses, 'Train Losses', 'Epochs', 'Loss')
    plot(test_losses, 'Test Losses', 'Epochs', 'Loss')
    plot(test_accuracies, 'Test Accuracies', 'Epochs', 'Accuracy')

